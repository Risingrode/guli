# 网关

前端与后端的网址不一致，需要一个网关来转发请求

# 跨域

在gateway中配置跨域请求

```java
// 这里的坑是不要导错包
@Configuration
public class GulimallCorsConfiguration {
    @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 1.配置跨域
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.addAllowedOrigin("*");
        // 2.配置是否发送cookie信息
        corsConfiguration.setAllowCredentials(true);
        source.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```

# 坑

1. product 里面不要加application.name，否则会报错

# 表的说明

category_brand_relation: 分类和品牌的关系表
IDEA中,鼠标放在表明上面，表的注释自动显现。

# P78

点击查询全部带上模糊查询的功能

vo: view object
接收页面传递过来的对象，封装对象。
把业务处理完成的对象，封装成页面要使用的数据。

# 三个配置文件的关系

application.yml: 全局配置文件，所有的配置都可以在里面找到
bootstrap.yml: 从配置中心获取配置信息
application.properties: 项目启动的时候，从本地获取配置信息

项目启动的时候，会从配置中心获取配置信息
如果配置中心没有配置信息，就会从本地获取配置信息

要使用配置中心就要在bootstrap.yml(bootstrap.properties)中来配置，bootstrap.yml配置文件的加载顺序要比application.yml要优先。

# 在nacos中配置

这里摔了大坑，在nacos里面搞好配置文件后，要加到bootstrap.properties中，
使用extension-configs进行配置，例子如下：

```properties
spring.application.name=gulimall-product
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=9eeb06b5-d257-403d-b78b-8af803b45994
spring.cloud.nacos.config.extension-configs[0].data-id=application.yml
spring.cloud.nacos.config.extension-configs[0].group=dev
spring.cloud.nacos.config.extension-configs[0].refresh=true
```

# DNS

> DNS代表域名系统（Domain Name System），它是互联网基础设施的一部分，
> 用于将人类可读的域名（如www.example.com）转换为计算机可理解的IP地址（如192.168.1.1）。
> DNS起到了类似电话簿的作用，帮助计算机找到特定域名对应的服务器IP地址，
> 从而实现网络上各种服务的定位。

# nacos基本属性说明

Namespace：代表不同环境，如开发、测试、生产环境；

Group：代表某项目，如XX医疗项目、XX电商项目；

DataId：每个项目下往往有若干个工程，每个配置集(DataId)是一个工程的主配置文件

# mybatis分页插件(config目录下面)

```java

@Configuration
@EnableTransactionManagement//开启事务 方法可以使用事务了
@MapperScan("com.atguigu.gulimall.product.dao")
public class MyBatisConfig {
    // 引入分页插件
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        paginationInterceptor.setOverflow(true);//设置请求的页面大于最大页后操作，true调回到首页，false继续请求，默认false
        paginationInterceptor.setLimit(1000);//设置最大单页限制数量，默认500条，-1不受限制
        return new PaginationInterceptor();
    }
}
```

这个类的作用域是在 Spring Boot 项目的整个运行环境中。具体来说，这个类的作用域涵盖了以下几个方面：

1. `@EnableTransactionManagement` 注解开启了整个类的事务管理。项目中所有使用了 `@Transactional` 注解的方法都会受到这个类的影响。
2. `@MapperScan("com.atguigu.gulimall.product.dao")` 在整个项目中，MyBatis 的 Mapper 接口会被自动扫描，并且相应的实现会被
   Spring 自动创建并注入到容器中。
3. `@Configuration` Spring 容器会扫描并加载该类，并将其中定义的 Bean 注册到容器中。

# feign 远程调用

```java

@FeignClient("gulimall-coupon")
public interface CouponFeignService {
    @PostMapping("/coupon/spubounds/save")
    R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo);

    @PostMapping("/coupon/skufullreduction/saveinfo")
    R saveSkuReduction(SkuReductionTo skuReductionTo);
}
```

1. `@FeignClient("gulimall-coupon")`: 这个注解标识了一个 Feign 客户端接口。括号中的字符串 "gulimall-coupon" 是要调用的远程服务的名称。
2. `@PostMapping("/coupon/spubounds/save")`: 用来调用远程服务的 "/coupon/spubounds/save" 路径。
3. `R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo)`: 这是一个接口方法，它使用 `@RequestBody`
   注解将参数对象 `spuBoundTo` 作为请求体发送给远程服务。
   这种方式使得服务之间的调用更加简洁，无需手动创建 HTTP 请求，而是直接通过接口方法来进行远程调用。

# `BeanUtils.copyProperties()`

`BeanUtils.copyProperties()` 用于将一个 Java 对象的属性值复制到另一个对象中。通常在对象之间属性相似但类型不同的情况下使用。
`BeanUtils.copyProperties(bounds, spuBoundTo);` 这样的用法。这个语句的作用是将对象 `bounds`
的属性值复制到对象 `spuBoundTo` 中。
`BeanUtils.copyProperties()` 方法会自动根据属性名匹配进行属性复制。
这个方法是基于属性名的匹配复制，不会考虑类型转换等复杂情况。如果属性名相同但类型不同，会抛出类型不匹配的异常。如果需要在属性名相同但类型不同的情况下进行复制，需要手动处理类型转换等情况。

# sql注解

## `@TableId`

1. **标识主键字段：** 通过在主键字段上添加 `@TableId` 注解，将该字段标识为实体类的主键。

2. **设置主键生成策略：** 可以通过 `@TableId` 的参数来指定主键生成策略，例如自增、UUID、雪花算法等。具体的生成策略取决于你所使用的数据库和框架。

## `@TableField`

1. **排除字段：** 通过 `@TableField(exist = false)` 注解可以将该字段排除在实体类之外，不会映射到数据库表中。
2. **自动填充字段：** 通过 `@TableField(fill = FieldFill.INSERT)` 注解可以将该字段标识为自动填充字段，这样在插入数据时，MyBatis
   Plus 会自动填充该字段的值。
3. **逻辑删除字段：** 通过 `@TableLogic` 注解可以将该字段标识为逻辑删除字段，这样在删除数据时，MyBatis Plus
   会自动将该字段的值设置为逻辑删除的值。
4. **乐观锁字段：** 通过 `@Version` 注解可以将该字段标识为乐观锁字段，这样在更新数据时，MyBatis Plus 会自动对该字段进行乐观锁控制。

## `@TableName`

在上面的示例中，`@TableName("user")` 指定了实体类 `User` 与数据库表 `user` 之间的映射关系。
当使用 MyBatis-Plus 进行数据库操作时，框架会根据注解的信息自动映射实体类属性和数据库表字段。
需要注意的是，`@TableName` 注解的值应该与数据库表的实际表名保持一致。这

## 自增，UUID，雪花算法

1. **自增（Auto Increment）：** 主要用于关系型数据库。每当插入一条新记录时，数据库会自动为该记录分配一个比前一条记录更大的唯一整数值。自增适用于单一数据库实例的应用，不适用于分布式系统。
2. **UUID（Universally Unique Identifier）：** UUID通常以字符串形式表示。UUID的优点是在分布式系统中保证唯一性，但缺点是占用较大的存储空间。
3. **雪花算法（Snowflake Algorithm）：**
   它将一个64位的整数划分成多个部分，用来表示时间戳、机器ID、数据中心ID等信息，从而生成唯一的ID。这种算法适用于分布式系统，能够在多节点之间生成唯一ID，且具有一定的顺序性。

# `Integer` 和 `int`

1. **空值处理：**
    - `int`：作为基本数据类型，不能存储空值（null）。
    - `Integer`：作为类，可以存储空值（null）。这在需要表示可能缺失的整数值时非常有用。

2. **等值比较：**
    - `int` 使用 `==` 运算符进行值的比较。
    - `Integer` 使用 `equals()` 方法进行值的比较，因为它是一个对象。

# Vo

VO（Value Object，值对象）是一种用于封装某些特定数据的对象。
它的出现主要是为了在不同的层或模块之间传递数据，以及为业务逻辑的解耦提供更好的支持。

# BigDecimal

Java 中的一个用于处理高精度数值计算的类。它用于表示任意精度的十进制数，可以处理需要高精度计算的场景，比如货币计算、税率计算、科学计算等。

# DTO

DTO（Data Transfer Object）是一种用于在不同层之间传输数据的设计模式，旨在解决在不同层（如应用层、业务逻辑层、数据访问层等）之间传输数据时的问题。

# 启动类注解

1. `@SpringBootApplication`：这是一个组合注解，它整合了多个注解，包括 `@SpringBootConfiguration`、`@EnableAutoConfiguration`
   和 `@ComponentScan`。
2. `@SpringBootConfiguration`：这是一个配置类注解，它的作用与 `@Configuration` 相同，都是用于标识当前类是一个配置类。
3. `@EnableAutoConfiguration`：这是一个自动配置注解，它的作用是启用 Spring Boot 的自动配置机制。
4. `@ComponentScan`：这是一个组件扫描注解，它的作用与 `@ComponentScan`
   相同，都是用于扫描指定包下的所有组件，包括 `@Component`、`@Service`、`@Controller` 等。
5. `@MapperScan`：这是一个 MyBatis 扫描注解，它的作用是扫描指定包下的所有 Mapper 接口，并将它们注册为 Spring Bean。
6. `@EnableTransactionManagement`：这是一个事务管理注解，它的作用是启用 Spring Boot 的事务管理机制。
7. `@ServletComponentScan`：这是一个 Servlet 组件扫描注解，它的作用是扫描指定包下的所有 Servlet 组件，并将它们注册为 Spring Bean。
8. `@EnableScheduling`：这是一个定时任务注解，它的作用是启用 Spring Boot 的定时任务机制。
9. `@EnableAsync`：这是一个异步任务注解，它的作用是启用 Spring Boot 的异步任务机制。
10. `@EnableCaching`：这是一个缓存注解，它的作用是启用 Spring Boot 的缓存机制。
11. `@EnableFeignClients(basePackages = "com.atguigu.gulimall.product.feign"）`: 开启远程调用
12. `@MapperScan("com.atguigu.gulimall.product.dao")` : 扫描mapper
13. `@EnableDiscoveryClient` : 开启服务注册发现功能

# `Controller`篇

## @RestController
- 这个注解表示该类是一个 Spring MVC 控制器，并且处理的请求的结果直接返回数据（而不是视图）。
- 在这个类中的方法，返回的数据会以 JSON 或其他格式返回给客户端。
- `@RequestMapping("product/attrattrgrouprelation")` : 定义该控制器处理的请求的基本路径。
- `@RequestMapping("/list")` : 将控制器方法映射到指定的请求路径。
- `@GetMapping("/list")` : 将控制器方法映射到指定的 GET 请求路径。
- `@RequestParam Map<String, Object> params` :从请求的参数中获取数据，并以键值对的形式存储在这个 Map 中。
- `PageUtils page` : 自定义工具类
- `R.ok().put("page", page)` : 返回数据
- `@RequestMapping("/sale/listforspu/{spuId}")` : 

## @Autowired 与 @Resource
1. **@Autowired：** 这是 Spring 的注解，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。
2. **@Resource：** 这是 Java 的注解，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。
3. **@Autowired：**
4. - 默认按照类型进行装配，如果有多个类型匹配时，再按照名称进行匹配。
   - 如果没有找到匹配的类型，则会抛出异常。
   - 如果有多个类型匹配时，可以使用 `@Qualifier` 注解指定要装配的 Bean 的名称。
   - 如果要使用 `@Autowired` 注解对方法或构造函数进行标注，则不能使用 `@Qualifier` 注解。

## 



































































